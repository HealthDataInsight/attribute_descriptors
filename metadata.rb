#
# This module let's you describe data in a YAML file and get a
# hash (aka dictionary) structure from it that can be used to automate a lot of
# things like form generation, data validators, etc.
#
# This is particularly useful when you want to generate a model and other components
# but without a database.
#
# Example
# -------
# Forename:
# Surname:
# NHS.net email address:
#   programmatic_name: nhsmail
#   validate: /.*@\.nhs\.net/
#
#
#    .. results in the metadata structure below..
#
# {
#   "Forename" => {
#      "require" => true,
#      "validate" => /.*/,
#      "min" => 0,
#      "max" => Infinity,
#      "values" => nil,
#      "max_num_values" => Infinity,
#      "min_num_values" => 0
#      "programmatic_name" => "forename"
#   },
#   "Surname" => {
#      "require" => true,
#      "validate" => /.*/,
#      "min" => 0,
#      "max" => Infinity,
#      "values" => nil,
#      "max_num_values" => Infinity,
#      "min_num_values" => 0
#      "programmatic_name" => "surname"
#   },
#   "NHS.net email address" => {
#      "validate" => "/.*@\\.nhs\\.net/",
#      "require" => true,
#      "min" => 0,
#      "max" => Infinity,
#      "values" => nil,
#      "max_num_values" => Infinity,
#      "min_num_values" => 0
#      "programmatic_name" => "nhsmail"
#   },
# }
#
module Metadata

  #
  # Reads a YAML configuration file specifying field names
  # and other meta data like minimum length, maximum length, etc.
  # and generates a structure that can be used in a view and/or model.
  #
  def self.load_file(filepath, defaults=nil)
    loaded = YAML.load_file(filepath)

    # Expand any field directives (ie. 'require=yes' ) in place
    #
    # Example:
    #    numbers: a=10 b=20
    #        ..becomes..
    #    numbers => {
    #      'a' => 10,
    #      'b' => 20
    #    }
    #
    loaded.each do |k,v|

      #
      # Default values
      #
      # values     -> probable values of the field
      # values_max ->
      params_hash = defaults || {
        'require'        => true,
        'validate'       => '.*',
        'max_length'     => nil,
        'min_length'     => 0,
        'min_value'      => 0,
        'max_value'      => nil,
        'values'         => nil,
        'max_num_values' => nil,
        'min_num_values' => 0,
      }

      # First do some preprocessing
      #   1. expand compact syntax for parameters (ie. a=10 b=20)
      #   2. load any missing parameters from defaults
      if v.nil?
        loaded[k] = params_hash
      elsif v.is_a? String
        if v.include? '='
          params = loaded[k].split()
          params.each do |param|
            name, value = param.split('=')
            params_hash[name] = YAML.load(value)
          end
          loaded[k] = params_hash
        else
          loaded[k] = YAML.load(v)
        end
      else
        params_hash.each {|nam,val| loaded[k][nam] = params_hash[nam] if ! loaded[k].include? nam}
      end

      # Insert any values that couldn't be generated at any previous step
      # IMPORTANT: Automatically generated programmatic names can elicit
      #            potential bugs. You are highly adviced to manually specify
      #            the field programmatic_name in your metadata file.
      if loaded[k]['programmatic_name'].nil?
        underscored = k.tr(' !"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~', '_')
        cleaned = underscored.split('_').select{|v| ! v.empty? }.join('_')
        loaded[k]['programmatic_name'] = cleaned.downcase
      end

      # Finally update values to the ones given by configuration file
      loaded[k].each do |name, value|
          if params_hash.include? name
            loaded[k][name] = value
          end
      end

    end

    return loaded
  end



  #
  # Inherit from Metadata::AutogeneratedModel in any model class that you want the
  # attributes and validations to be generated automatically based on metadata.
  #
  #   1. Have your model inherit from AutogeneratedModel
  #   2. Use generated_from in your model to load metadata from a specific file
  #   3. YOU NEED TO ADD MANUALLY THE MODEL VALIDATIONS CURRENTLY
  #
  # attrs - the attributes you wish to populate
  #
  class AutogeneratedModel

    # Needed for the validations
    include ActiveModel::Validations

    def initialize(attrs = {})

      if @@metadata.nil?
        raise "You need to call 'generated_from' in your class to specify the metadata path"
      end

      # Accept as attributes only the ones specified in the metadata
      programmatic_names = @@metadata.collect {|k_,v| v['programmatic_name']}
      accepted_model_attrs = attrs.select do |name, value|
        programmatic_names.include? name
      end

      # Generate attribute accessors based on metadata
      accepted_model_attrs.each do |name, value|
        self.class.send(:attr_accessor, name)
      end

      # Set attributes
      accepted_model_attrs.each do |name, value|
        self.send("#{name}=", value)
      end

      # IMPORTANT: All code below doesn't work for Rails 3. However it seems to
      #            work fine with Rails 4. Further adjustment might be needed.
      #
      #self.class.module_eval { validates_presence_of :forename }
      #self.validates_presence_of :forename
      #Generate validations based on the metadata
      # metadata.each do |field, meta|
      #   if meta['require']
      #     class_eval { validates_presence_of meta['programmatic_name'] }
      #   end
      #   class_eval { validates_format_of meta['programmatic_name'], :with    => Regexp.new(meta['validate']) }
      #   class_eval { validates_length_of meta['programmatic_name'], :minimum => meta['min_length'] if ! meta['min_length'].nil? }
      #   class_eval { validates_length_of meta['programmatic_name'], :maximum => meta['max_length'] if ! meta['max_length'].nil?}
      # end

    end

    def self.generated_from(filepath)
      @@metadata = Metadata.load_file(filepath)
    end


  end


end
