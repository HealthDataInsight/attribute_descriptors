require 'active_model'

#
# This module let's you describe data in a YAML file and get a
# hash (aka dictionary) structure from it that can be used to automate a lot of
# things like form generation, data validators, etc.
#
# This is particularly useful when you want to generate a model and other
# components but without a database.
#
# Example
# -------
# Forename:
# NHS.net email address:
#   programmatic_name: nhsmail
#   validate: .*@\.nhs\.net
#
#    .. results in the metadata structure below..
#
# {
#   "Forename" => {
#      "require" => true,
#      "validate" => /\A.*\z/,
#      "min" => 0,
#      "max" => Infinity,
#      "values" => nil,
#      "max_num_values" => Infinity,
#      "min_num_values" => 0
#      "programmatic_name" => "forename"
#   },
#   "NHS.net email address" => {
#      "validate" => /\A.*@\\.nhs\\.net\z/,
#      "require" => true,
#      "min" => 0,
#      "max" => Infinity,
#      "values" => nil,
#      "max_num_values" => Infinity,
#      "min_num_values" => 0
#      "programmatic_name" => "nhsmail"
#   },
# }
#
module Metadata

  INFINITY = Float::INFINITY

  def self.load_file(filepath, defaults = nil)
    f = open(filepath, 'r')
    file_content = f.read
    f.close
    load_yaml(file_content, defaults)
  end

  # Reads raw YAML metadata specifying data name, length, max values, etc.
  def self.load_yaml(yaml, defaults = nil)
    metadata = YAML.load(yaml)

    metadata.each do |fieldname, meta|
      params = defaults || {
        'require'        => true,
        'validate'       => /.*/,
        'max_length'     => nil,
        'min_length'     => 0,
        'min_value'      => 0,
        'max_value'      => nil,
        'values'         => nil,
        'max_num_values' => nil,
        'min_num_values' => 0
      }

      # Expand compact syntax (ie. a=10 b=20)
      #
      # field1: require=true example=jojo
      #   validate: .*
      #
      #     ..gives the meta..
      # "field1" => "require=true example=jojo validate=.*"
      #
      if meta.is_a? String # This is always true if compact syntax is used
        asssignments = meta.split(' ')
        metadata[fieldname] = {}
        asssignments.each do |assignment|
          k, v = assignment.split('=')
          metadata[fieldname][k] = v
        end
      end

      # Add any missing paramaters from defaults
      params.each do |k, _v|
        metadata[fieldname][k] = params[k] unless metadata[fieldname].include? k
      end

      # Generate a programmatic_name based on the fieldname if none explicitly
      # given
      #
      # IMPORTANT: Automatically generated programmatic names might be too long.
      #            You are advised to explicitly add the programmatic_name for
      #            each field in your metadata file.
      if metadata[fieldname]['programmatic_name'].nil?
        underscored = fieldname.tr(' !"#$%&\'()*+,-./:;<=>?@[\\]^_`{ |}~', '_')
        singly_underscored = underscored.split('_').select { |v| !v.empty? }\
                                        .join('_')
        metadata[fieldname]['programmatic_name'] = singly_underscored
      end

      # Finally update/evaluate values to the ones given by configuration file
      metadata[fieldname].each do |name, value|
        case name
        when 'validate'
          if value.is_a?(String)
            value = value[1...-1] if value.start_with?('/') && \
                                     value.end_with?('/')

            # Enforce the \A..\z regex placeholders for security reasons
            # (http://guides.rubyonrails.org/security.html#regular-expressions)
            value = value[1..-1]  if value.start_with?('^')
            value = value[0...-1] if value.start_with?('$')
            value = '\A' + value unless value.start_with?('\A')
            value += '\z' unless value.end_with?('\z')
          end
          metadata[fieldname][name] = Regexp.new(value)
        else
          metadata[fieldname][name] = value
        end
      end
    end

    # Swap attribute description with programmatic_name as key
    # since inside the code the programmatic_name makes it easier
    # to access speicfic attributes in the metadata.
    metadata_new = {}
    metadata.each do |fieldname, name|
      programmatic_name = metadata[fieldname]['programmatic_name']
      metadata_new[programmatic_name] = metadata[fieldname]
      metadata_new[programmatic_name]['description'] = fieldname
    end
    metadata = metadata_new

    metadata
  end

  #
  # This class, once inherited let's you generate attributes and validations
  # based on metadata in a YAML file.
  #
  # IMPORTANT: This has only be tested being used on models that don't rely on
  #            a database.
  #
  # Usage:
  #   1. Have your model inherit from AutogeneratedModel
  #   2. Use generated_from in your model to load metadata from a specific file
  #
  class AutogeneratedModel
    include ActiveModel::Validations

    #
    # (API) Access metadata
    #
    def metadata
      @@metadata || nil
    end
    def self.metadata
      @@metadata || nil
    end

    #
    # (API) Load metadata and perform actions
    #
    # This runs on class level (aka before instance initialization)
    #
    def self.generated_from(filepath)
      @@metadata = Metadata.load_file(filepath)

      # Generate attribute accessors based on metadata
      programmatic_names = @@metadata.collect { |_k, v| v['programmatic_name'] }
      programmatic_names.each do |name|
        class_eval { attr_accessor name }
      end

      # Generate validations based on metadata
      @@metadata.each do |_field, meta|
        length = {}
        length[:minimum] = meta['min_length'] if meta['min_length'] && \
                                                 meta['min_length'] > 0
        length[:maximum] = meta['max_length'] if meta['max_length'] && \
                                                 meta['max_length'] != INFINITY
        validation_params = {}
        validation_params[:format]      = meta['validate']
        validation_params[:allow_blank] = !meta['require']
        validation_params[:length]      = length if !length.empty?
        validation_params[:presence]    = true if meta['require']
        validates meta['programmatic_name'], validation_params
      end
    end

    def initialize(attrs = {})
      fail 'You need to call \'generated_from\' in your class '\
           'to specify the metadata path' if metadata.nil?

      # Set attributes
      attrs.each do |name, value|
        send("#{name}=", value) if programmatic_names.include? name
      end
    end

    # Gives back the attributes of the model
    def self.attributes
      @@metadata.collect { |_k, v| v['programmatic_name'] }
    end

    # Gives back the required attributes of the model
    def self.required_attributes
      required = @@metadata.select do |_fieldname, meta|
        meta['require']
      end
      required.collect { |_fieldname, meta| meta['programmatic_name'] }
    end

    private

    def programmatic_names
      @@metadata.collect { |_k, v| v['programmatic_name'] }
    end
  end

end
